# Copyright (C) 2021 Axellio, Inc. All rights reserved
# This is the Axellio packetXpress configuration file. This file is used by all
# Axellio python applications. Each application will use different sections of
# this file. A section is defined by the heading using brackets, e.g. [section]

# For some applications, there are thread settings that allow control of which
# CPU cores the threads can be scheduled on as well as their scheduler policy
# and priorities.
#
# The format of the thread settings is
#   cpuList [ ; threadPolicy [ ; threadPriority ] ]
#
# cpuList is a list of numbers and ranges using '-' or '..' with comma
# separators between entries
#       n [,n] [,n-m] [,n..m]
#   n and m are integer values in the range 0-255
#
# threadPolicy is one of
#   other - Default thread policy, threadPriority must be zero, see man
#       sched_setscheduler
#   fifo - Real time FIFO policy, threadPriority must be in the range 1-99, see
#       man sched_setscheduler
#   rr | round_robin - Real time Round Robin policy, threadPriority must be in
#       the range 1-99, see man sched_setscheduler

###############################################################################
# The pxSystem section contains global settings. All applications have internal
# default settings that they apply first. Those are overridden by any pxSystem
# setting, then any application specific settings, and finally any command line
# arguments.
#
# Any settings in the pxSystem section that are not found in the application
# section are ignored for that application.
[pxSystem]

# This is the one place to change the install path. All other paths in this file
# are expected to be relative to this path.
axellio_install_path = /opt/axellio

# disk_device is the path to the physical device for the packetXpress file
# system volume. Normally, this is going to be an MDADM volume.
disk_device = ${axellio_install_path}/pxfs-phys-dev

# license_file is the path to the license for this system. Each host/system has a
# unique license file.
license_file = ${axellio_install_path}/config/license.axellio

# license_public_key_file is the path to the crypto verification public key file.
# The public key file and the license file (see license_file) are a pair.
license_public_key_file = ${axellio_install_path}/config/licenseKey.pub

# user is the user name to apply to all files/directories that are created. user
# must be a valid user on this system.
user = fxadmin

# group is the group name to apply to all files/directories that are created.
# group must be a valid group on this system.
group = apcnoperators

# audit log path is the filesystem location where the program audit logs
# are created. This path directory must exist.
audit_log_path = /opt/axellio/log

###############################################################################
# The pxcapture section contains settings for the pxcapture process.
[pxCapture]

# rc_port is the TCP/IP port this application will listen on for remote control
# and status. Valid range is 0 to 65535.
rc_port = 20001

# reader_port is the TCP/IP port this application will listen on for reader
# application management. Readers need to connect to this application in order
# to manage their reading of the disk and prevent starving the writer processes.
# Valid range is 0 to 65535. A value of 0 disables this functionality.
reader_port = 21001

# compress can be 'none' or 'lz4'. none will disable compression of data being
# written to disk. lz4 will use lz4_acceleration to set the compression level of
# all data being written to disk.
compress = none

# lz4_acceleration is only used if compress is set to lz4. The value of zero (0)
# uses automatic load balancing compression levels. Any value of >= 1 fixes the
# compression to that level. A lower value is higher compression and uses more
# CPU. When acceleration settings of >= 1 are used, the software will discard
# data if the CPUs are unable to compress the data and keep up with the input
# data rate. Valid range is 0 to 32767.
lz4_acceleration = 0

# The capture node will create new files on a maximum file size or time
# boundary, whichever comes first. max_file_size_gb has a range of 1 to 4096GB.
max_file_size_gb = 50

# The capture node will create new files on a maximum file size or time
# boundary, whichever comes first. max_file_size_sec has a range of 0 to 86400
# seconds (1 day). When this is zero, there is no maximum file size in time.
max_file_size_sec = 0

# logger can be 'syslog' or 'printf'. syslog will send all logs to the syslog
# facility. printf will send all logs to the stdout
logger = syslog

# verbose set to true will increase the log level to include state changes and
# debug logging.
verbose = false

# ntpl defines the directory to find *.ntpl files in to configure the hardware
# filtering. Files are sorted by name and then applied to the hardware.
ntpl = ${pxSystem:axellio_install_path}/filter

# disk_full_pct defines when the disk is considered full. When the disk reaches
# this percentage full, the oldest files are deleted until the disk full
# percentage is below this value. The valid range for this is 2 to 98 percent.
disk_full_pct = 98

# user and group are meant to be set by the pxSystem section but can be
# overridden here for just this program if desired.
#user =
#group =

# nt_adapter defines which Napatech adapter to capture data from. Range is 0 to 9
# and must represent a valid Napatech adapter number.
nt_adapter = 0

# segment_buffers defines how many segment buffers are to be allocated for queue
# depth for each stream ID. Each buffer takes up about 4MB of memory. Valid
# range is 16 to 32768.
segment_buffers = 1024

# index_compress_threads defines the number of threads to use for indexing and
# compression. Valid range is 1 to 256.
index_compress_threads = 24

# file_writer_threads defines the number of threads to use for writing files.
# Valid range is 1 to 256.
file_writer_threads = 3

# max_io_depth defines the maximum number of I/Os that will be queued to the disk
# devices by each file writer thread. Thus file_writer_threads times max_io_depth
# number of I/Os may be pending. Valid range is 2 to 64.
max_io_depth = 48

# Files are named using the information below. When a file is created by the
# capture program, the start time field is created using the start time format
# string and the timestamp of the first packet for the file. The file is named
# using the file_name_start_time_format plus the
# file_name_extension_while_open. If that name generates a naming conflict then
# the file name becomes the file_name_start_time_format plus the conflict
# separator plus a 9-digit first packet nano-seconds field plus
# file_name_extension_while_open.
#
# Once the file is closed, the file is renamed using the open file name without
# the extension, the file_name_end_time_format and the extension value.
#
# The file_name_start_time_format and file_name_end_time_format are format
# strings using printf like formatting characters below. These are very similar
# to strftime formatting strings. None of the file name formatting strings may
# contain any tab, carriage return, new line, /, or \ characters.
#
#   %Y - 4 digit year
#   %y - 2 digit year (00..99)
#   %m - 2 digit month
#   %d - 2 digit day of month
#   %H - 2 digit 24 hour (00-23)
#   %I - 2 digit 12 hour (01-12)
#   %M - 2 digit minute
#   %S - 2 digit seconds
#   %n - 9 digit nano-seconds
#   %j - day of year (001-366)
#   %s - posix seconds since 1970
#
file_name_start_time_format = %s
file_name_conflict_sep = _
file_name_extension_while_open = .pcap
# When using the end time field, its value is appended to the start time field.
# You probably want to specify some type of separator value at the beginning of
# the end time field.
file_name_end_time_format =
file_name_extension = .pcap

# disk_device, license_file, and license_public_key_file are meant to be set by
# the pxSystem section but can be overridden here for just this program if
# desired.
#disk_device =
#license_file =
#license_public_key_file =

# The axTimeoutsSingleton thread is used to generate statistics and is a low
# priority thread.
axTimeoutsSingleton =

# There is one NtRead and one Stream thread per stream ID configured in NTPL
axNtRx/NtRead* =
axFileWriter/Stream* =

# There is one accounting thread
axNtRx/Accounting =

# There are index_compress_threads number of Indexer threads
axIndexCompress/Indexer* =

# There is only one merge thread at the output of the Indexer
axIndexCompress/Merge =

# There are file_writer_threads number of IoWriter threads
axFileWriter/IoWriter* =

# There is only one descriptor writer thread
axFileWriter/DescWrite =

# There is one thread to handle the reader network clients and one thread
# listening for new client connections. The thread listening for client
# connections has the port number in its name as in 'TcpServer/Listen:21001'.
# We use the star to allow the port number to change without requiring an ini
# file update.
axFileWriter/Clients =
axFileWriter/TcpServer* =

# The FreeSpace thread recognizes when the disk is full and deletes old files to
# make room for new files
axDiskManager/FreeSpace =

###############################################################################
# This section contains settings for the pxingestpcap process.
[pxingestpcap]

# rc_port is the TCP/IP port this application will listen on for remote control
# and status. Valid range is 0 to 65535.
rc_port = 20001

# reader_port is the TCP/IP port this application will listen on for reader
# application management. Readers need to connect to this application in order
# to manage their reading of the disk and prevent starving the writer processes.
# Valid range is 0 to 65535. A value of 0 disables this functionality.
reader_port = 21001

# compress can be 'none' or 'lz4'. none will disable compression of data being
# written to disk. lz4 will use lz4_acceleration to set the compression level of
# all data being written to disk.
compress = none

# lz4_acceleration is only used if compress is set to lz4. The value of zero (0)
# uses automatic load balancing compression levels. Any value of >= 1 fixes the
# compression to that level. A lower value is higher compression and uses more
# CPU. When acceleration settings of >= 1 are used, the software will discard
# data if the CPUs are unable to compress the data and keep up with the input
# data rate. Valid range is 0 to 32767.
lz4_acceleration = 0

# The capture node will create new files on a maximum file size or time
# boundary, whichever comes first. max_file_size_gb has a range of 1 to 4096GB.
max_file_size_gb = 8192

# The capture node will create new files on a maximum file size or time
# boundary, whichever comes first. max_file_size_sec has a range of 0 to 86400
# seconds (1 day). When this is zero, there is no maximum file size in time.
max_file_size_sec = 0

# logger can be 'syslog' or 'printf'. syslog will send all logs to the syslog
# facility. printf will send all logs to the stdout
logger = syslog

# verbose set to true will increase the log level to include state changes and
# debug logging.
verbose = false

# disk_full_pct defines when the disk is considered full. When the disk reaches
# this percentage full, the oldest files are deleted until the disk full
# percentage is below this value. The valid range for this is 2 to 100 percent.
disk_full_pct = 100

# user and group are meant to be set by the pxSystem section but can be
# overridden here for just this program if desired.
#user =
#group =

# segment_buffers defines how many segment buffers are to be allocated for queue
# depth for each stream ID. Each buffer takes up about 4MB of memory. Valid
# range is 16 to 32768.
segment_buffers = 1024

# index_compress_threads defines the number of threads to use for indexing and
# compression. Valid range is 1 to 256.
index_compress_threads = 4

# file_writer_threads defines the number of threads to use for writing files.
# Valid range is 1 to 256.
file_writer_threads = 3

# max_io_depth defines the maximum number of I/Os that will be queued to the disk
# devices by each file writer thread. Thus file_writer_threads times max_io_depth
# number of I/Os may be pending. Valid range is 2 to 64.
max_io_depth = 48

# Files are named using the information below. When a file is created by the
# capture program, the start time field is created using the start time format
# string and the timestamp of the first packet for the file. The file is named
# using the file_name_start_time_format plus the file_name_extension_while_open. If that
# name generates a naming conflict then the file name becomes the
# file_name_start_time_format plus the conflict separator plus a 9-digit first
# packet nano-seconds field plus file_name_extension_while_open.
#
# Once the file is closed, the file is renamed using the open file name without
# the extension, the file_name_end_time_format and the extension value.
#
# The file_name_start_time_format and file_name_end_time_format are format strings using
# printf like formatting characters below. These are very similar to strftime
# formatting strings. None of the file name formatting strings may contain any
# tab, carriage return, new line, /, or \ characters.
#
#   %Y - 4 digit year
#   %y - 2 digit year (00..99)
#   %m - 2 digit month
#   %d - 2 digit day of month
#   %H - 2 digit 24 hour (00-23)
#   %I - 2 digit 12 hour (01-12)
#   %M - 2 digit minute
#   %S - 2 digit seconds
#   %n - 9 digit nano-seconds
#   %j - day of year (001-366)
#   %s - posix seconds since 1970
#
file_name_start_time_format = %s
file_name_conflict_sep = _
file_name_extension_while_open = .pcap
# When using the end time field, its value is appended to the start time field.
# You probably want to specify some type of separator value at the beginning of
# the end time field.
file_name_end_time_format =
file_name_extension = .pcap

# disk_device, license_file, and license_public_key_file are meant to be set by the
# pxSystem section but can be overridden here for just this program if desired.
#disk_device =
#license_file =
#license_public_key_file =

# The axTimeoutsSingleton thread is used to generate statistics and is a low
# priority thread.
axTimeoutsSingleton =

# There are index_compress_threads number of Indexer threads
axIndexCompress/Indexer* =

# There is only one merge thread at the output of the Indexer
axIndexCompress/Merge =

# There are file_writer_threads number of IoWriter threads
axFileWriter/IoWriter* =

# There is only one descriptor writer thread
axFileWriter/DescWrite =

# There is one thread to handle the reader network clients and one thread
# listening for new client connections. The thread listening for client
# connections has the port number in its name as in 'TcpServer/Listen:21001'.
# We use the star to allow the port number to change without requiring an ini
# file update.
axFileWriter/Clients =
axFileWriter/TcpServer* =

# The FreeSpace thread recognizes when the disk is full and deletes old files to
# make room for new files
axDiskManager/FreeSpace =

###############################################################################
# The pxextract section contains settings for all pxextract application
# instances. If pxextract is executed with the --config <name> command line
# option then the pxextract-name section will override these settings.
[pxextract]

# rc_port is the TCP/IP port this application will listen on for remote control
# and status. Valid range is 0 to 65535.
rc_port = 20010

# capture_ip_addr is the TCP/IP address of the capture application. Readers need
# to connect to this in order to manage their reading of the disk and prevent
# starving the writer processes. An empty IP Address value disables this
# functionality.
capture_ip_addr =

# capture_port is the TCP/IP port of the capture application management port.
# Readers need to connect to this in order to manage their reading of the disk
# and prevent starving the writer processes. Valid range is 0 to 65535. A value
# of 0 disables this functionality.
capture_port = 21001

# archive_ip_addr is the TCP/IP address of the archive application. Readers need
# to connect to this in order to manage their reading of the archive and prevent
# starving the writer processes. An empty IP Address value disables this
# functionality.
archive_ip_addr =

# archive_port is the TCP/IP port of the archive application management port.
# Readers need to connect to this in order to manage their reading of the
# archive and prevent starving the writer processes. Valid range is 0 to 65535.
# A value of 0 disables this functionality.
archive_port = 21010

# default_start_time is the default start time value if no -T or --timestamp
# command line options are present. A start time of 0 means use the earliest
# available data on the disk. A start time of -1 means 'now'. Data with a
# timestamp >= default_start_time and < default_end_time will be processed. Valid
# range is -1 to 4294967295.
default_start_time = -1

# default_end_time is the default end time value if no -T or --timestamp command
# line options are present. An end time of -1 means run forever. The end time
# must be larger than the start time if it is not -1. Data with a timestamp >=
# default_start_time and < default_end_time will be processed. Valid range is -1 to
# 4294967295.
default_end_time = -1

# timezone only modifies the time zone for the --time command line option. The
# valid range for this is 'local' or 'gmt'.
timezone = gmt

# filter is either a BPF filter string (see man 7 pcap-filter) or a tuple
# filter. A tuple filter contains five values with comma separators as follows:
# source_ip,dest_ip,source_port,dest_port,protocol
filter =

# The stream_ids is a list of numbers and ranges using '-' or '..' with comma
# separators between entries
#       n [,n] [,n-m] [,n..m]
#   n and m are integer values in the range 0-255
stream_ids =

# Maximum rate in Mbps to allow extraction of data from the disk. A value of 0
# means no maximum.
max_rate = 0

# ip_addr is the IP address of where to send the output packets to
ip_addr =

# port is the TCP/IP port of where to send the output packets to. Valid range is
# 0 to 65535.
port = 9116

# tx_sock_buffer_len is the size of the TCP/IP socket buffer (in bytes) to use when
# sending output packets. A larger socket buffer can speed up the data flow if
# the system allows larger socket buffers. An administrator will need to enable
# larger socket buffers with a mechanism such as
#     'sudo sysctl -w net.core.wmem_max=16777216'.
# To make this take effect properly, the receiving system must also set its
# buffer size larger. See rx_sock_buffer_len in the pxrecv application settings.
# Valid range is 16384 to 2147483647.
tx_sock_buffer_len = 0x34000

# tcp_no_delay when true will turn off the nagle algorithm and allow output data
# to be sent more quickly. This is useful if the data flow is very slow but can
# negatively impact system performance in some cases.
tcp_no_delay = false

# ring can be set instead of ip_addr and port to output packets directly to a
# shared memory ring buffer like pxrecv does. When ring is true, ip_addr and port
# are ignored.
ring = false

# num_rings is used when ring is true and defines the number of ring buffers to
# distribute the data to. Valid range is 1 to 32.
num_rings = 20

# ring_mode is used when ring is true and defines the load distribution mode of
# the ring buffer. Valid values are 'disabled', 'round_robin', and
# 'five_tuple_hash'. If one ring is in use then the only valid mode is disabled
# but other modes will silently be accepted. When more than one ring is in use,
# round_robin or five_tuple_hash must be specified.
ring_mode = five_tuple_hash

# For normal operation, ignore_ring_full should be false. For performance testing
# purposes, setting ignore_ring_full to true will discard data when the output
# ring is full.
ignore_ring_full = false

# logger can be 'syslog' or 'printf'. syslog will send all logs to the syslog
# facility. printf will send all logs to the stdout
logger = syslog

# verbose set to true will increase the log level to include state changes and
# debug logging.
verbose = false

# Define the number of file reader threads for each stream ID. Three threads is
# enough for >100Gbps performance for a single stream ID. Valid range is 1 to
# 256.
file_reader_threads = 3

# Define the number of decompression threads for this application. Decompression
# can take quite a bit of CPU depending on the compression level. More threads
# may be required depending on the compression level achieved. Valid range is 1
# to 256.
decompress_threads = 4

# Define the number of filtering threads for this application. Depending on the
# filter type and setting, more threads may be needed to keep application
# performance at full speed. Valid range is 1 to 256.
filter_threads = 6

# max_io_depth defines the maximum number of I/Os that will be queued to the disk
# devices by each file reader thread. Thus file_reader_threads times numStreamIds
# times max_io_depth number of I/Os may be pending. Valid range is 2 to 64.
max_io_depth = 48

# max_q_depth defines the maximum number of queued requests in the system per
# stream ID. This is used for system memory and performance tuning. The valid
# range is 192 to 16384 depending on available system memory.
max_q_depth = 1024

# output_file defines a file to write the output packets to. Normally this would
# only be specified on the command line. Writing an output file can be done in
# parallel to the ip_addr:port and ring buffer modes.
output_file =

# The net_handle value can be used to uniquely identify the connection data
# stream. When a new network connection is made to send packets, a header is
# sent to the receiver. That header contains this value. At this time, no
# Axellio applications are using this value. Valid range is 0 to 4294967295.
net_handle = 0

# disk_device is meant to be set by the pxSystem section but can be overridden
# here for just this program if desired.
#disk_device =

# The axTimeoutsSingleton thread is used to generate statistics and is a low
# priority thread.
axTimeoutsSingleton =

# The file reader reads meta-data from the disk, dispatches it to multiple data
# reader threads and then merges the output back into an ordered stream. To
# support multiple streams, the file readers are named with the stream number as
# in 'axFileReader2_stream_3' is a file reader for stream 3.
axFileReader2_stream_*/MetaReader =
axFileReader2_stream_*/MetaDispatch =
axFileReader2_stream_*/DataReader* =
axFileReader2_stream_*/Merge =
axFileReader2_stream_*/CaptureComm =

axArchiveFileReader/ArchiveComm =
axArchiveFileReader/Reader =

# The decompress code uses multiple threads to decompress the data
axSegmentDecompress/Decompress* =

# The filter code uses multiple threads to filter the data using BPF or Tuple
# filtering.
axSegmentFilter/Filter* =

# The sorter code uses a single thread to sort all segments by timestamp
axSegmentSorter/Merge =

# axTcpTxSegment is only used when network output is used (ip_addr:port)
axTcpTxSegment/ClientThread =

# axSegmentToFile is only used with the output_file option
axSegmentToFile/FileThread =

# axSegmentToRing is only used with the ring option
axSegmentToRing/RingThread =

###############################################################################
# This is an example of how to override the pxextract settings when --config VM1
# is used on the pxextract command line.
#[pxextract-VM1]
#ip_addr = localhost
#port = 9116

###############################################################################
# The pxrecv section contains settings for the pxrecv application.
[pxrecv]

# rc_port is the TCP/IP port this application will listen on for remote control
# and status. Valid range is 0 to 65535.
rc_port = 20000

# port is the TCP/IP server port that this application will listen for
# connections on. The TCP/IP client such as pxextract must establish a
# connection to this application using this port.
port = 9116

# rx_sock_buffer_len is the size of the TCP/IP socket buffer (in bytes) to use when
# receiving packets. A larger socket buffer can speed up the data flow if the
# system allows larger socket buffers. An administrator will need to enable
# larger socket buffers with a mechanism such as
#     'sudo sysctl -w net.core.rmem_max=16777216'.
# To make this take effect properly, the sending system must also set its buffer
# size larger. See tx_sock_buffer_len in the pxextract application settings. Valid
# range is 16384 to 2147483647.
rx_sock_buffer_len = 0x34000

# num_ring_sets defines the number of sets of rings. Valid range is 1 to 16.
num_ring_sets = 1

# ring_sets is a list of numbers and ranges using '-' or '..' with comma
# separators between entries
#       n [,n] [,n-m] [,n..m]
#   n and m are integer values in the range 0-255
# This defines the ring set ids that are written by this receiver.
ring_sets = 0

# num_rings defines the number of ring buffers to distribute the data to. Valid
# range is 1 to 32.
num_rings = 20

# ring_mode defines the load distribution mode of the ring buffer. Valid values
# are 'disabled', 'round_robin', and 'five_tuple_hash'. If one ring is in use
# then the only valid mode is disabled but other modes will silently be
# accepted. When more than one ring is in use, round_robin or five_tuple_hash
# must be specified.
ring_mode = five_tuple_hash

# For normal operation, ignore_ring_full should be false. For performance testing
# purposes, setting ignore_ring_full to true will discard data when the output
# ring is full.
ignore_ring_full = false

# For normal operation, receive_only should be false. For network performance
# testing purposes, setting receive_only to true will discard all data after
# receiving it on the network.
receive_only = false

# file_name can specify the output file for the received packet data. Normally
# this would only be specfied on the command line.
file_name =

# logger can be 'syslog' or 'printf'. syslog will send all logs to the syslog
# facility. printf will send all logs to the stdout
logger = syslog

# verbose set to true will increase the log level to include state changes and
# debug logging.
verbose = false

# max_q_depth defines the maximum number of queued requests in the system. This is
# used for system memory and performance tuning. The valid range is 4 to 16384
# depending on available system memory.
max_q_depth = 64

# The axTimeoutsSingleton thread is used to generate statistics and is a low
# priority thread.
axTimeoutsSingleton =

# The listen thread is named with the listen port (see --port). There is one
# listen thread. The thread is named axTcpRxSegment/TcpServer/Listen:* but the
# colon is parsed like the equal sign and can not be used in this file.
axTcpRxSegment/TcpServer/Listen* =

# Each connected client is named with the port it is connected with. Therefore
# it is expected that only one entry will be used to specify the thread (because
# the port numbers are usually random). The thread is named
# axTcpRxSegment/Client:* but the colon is parsed like the equal sign and can
# not be used in this file.
axTcpRxSegment/Client* =

# Each connected client ping thread is named with the port it is connected with.
# Therefore it is expected that only one entry will be used to specify the ping
# thread (because the port numbers are usually random). The thread is named
# axTcpRxSegment/Ping:* but the colon is parsed like the equal sign and can not
# be used in this file.
axTcpRxSegment/Ping* =

# The file thread transfers data from the internal queue to the output file when
# the file_name is specified.
axSegmentToFile/FileThread =

# The ring thread transfers data from the internal queue to the ring buffers
axSegmentToRing/RingThread =

###############################################################################
# The pxfuse section contains settings for the pxfuse application.
[pxfuse]

# rc_port is the TCP/IP port this application will listen on for remote control
# and status. Valid range is 0 to 65535.
rc_port = 20060

# file_path is the pxFs file system path to mount with the fuse file system.
file_path = /

# mount_path is the linux file system directory path where the pxFs file system
# will be mounted
#mount_path =

# fuse_debug is used to enable the FUSE file system debugging logs
fuse_debug = false

# fuse_options can be used to set the fuse options found in man mount.fuse. For
# instance, allow_other can be set using this. Options should be defined as a
# single string with comma separators.
fuse_options =

# logger can be 'syslog' or 'printf'. syslog will send all logs to the syslog
# facility. printf will send all logs to the stdout
logger = syslog

# verbose set to true will increase the log level to include state changes and
# debug logging.
verbose = false

# disk_device is meant to be set by the pxSystem section but can be overridden
# here for just this program if desired.
#disk_device =

# The axTimeoutsSingleton thread is used to generate statistics and is a low
# priority thread.
axTimeoutsSingleton =

# There is one fuse thread
axFuse/FuseMain =

###############################################################################
# The pxmon section contains settings for the pxmon process. Since pxmon can be
# run multiple times on the same system to monitor many different applications,
# some of the settings are not expected to be part of this configuration file.
[pxmon]

# raw_values of false will display values with units of K,M,G,T as in KB, MB,
# etc. When raw_values is true, the value is displayed as a number.
raw_values = false

# bytes_per_second will choose to display data as bits per second (false) or bytes
# per second (true)
bytes_per_second = false

# summary of false will display statistics for all threads. When summary is true
# then only the summary statistics are displayed.
summary = true

# show_queue of false will not display the queue statistics. The queues are
# internal and documentation is not provided as to their usage. show_queue of
# true will display the queue statistics.
show_queue = false

# When run is zero, pxmon will display the data and cursor up to rewrite the
# display each interval time period until the user presses ctrl-c or otherwise
# stops the program from running. When run is greater than zero, pxmon will
# print the statistics run number of times and then shut down. Valid range is
# 0..1000000.
run = 0

# interval defines the time between statistics refreshes in seconds. Valid range
# is 0.1 to 86,400 seconds.
interval = 0.2

# ip_addr is the IP Address for pxmon to connect to using the TCP/IP port
# provided on the command line.
ip_addr = localhost

# port is the TCP port number for pxmon to connect to. If left unset here then
# the user must specify it on the command line.
#port =

###############################################################################
# The pxls section contains settings for the pxls application.
[pxls]

# When subsec is true, time values are displayed with sub-seconds data. When
# subsec is false, time values are displayed with only the seconds value.
subsec = false

# When all is true, all individual files are listed. When all is false, a
# summary of the captured data on the disk is presented.
all = false

# When recursive is true, the directory listing will recurse below the starting
# point and list all sub-directory contents. This option only takes effect when
# the all option is also true. When recursive is false, only the one directory
# is listed.
recursive = false

# logger can be 'syslog' or 'printf'. syslog will send all logs to the syslog
# facility. printf will send all logs to the stdout
logger = syslog

# verbose set to true will increase the log level to include state changes and
# debug logging.
verbose = false

# disk_device is meant to be set by the pxSystem section but can be overridden
# here for just this program if desired.
#disk_device =

###############################################################################
# The pxdumpbitmap section contains settings for the pxdumpbitmap application.
[pxdumpbitmap]

# logger can be 'syslog' or 'printf'. syslog will send all logs to the syslog
# facility. printf will send all logs to the stdout
logger = syslog

# verbose set to true will increase the log level to include state changes and
# debug logging.
verbose = false

# disk_device is meant to be set by the pxSystem section but can be overridden
# here for just this program if desired.
#disk_device =

###############################################################################
# The pxdumpdesc section contains settings for the pxdumpdesc application.
[pxdumpdesc]

# Identify a specific descriptor layer to display. To display all layers use a
# value of -2. To display the top layer only use a value of -1. All other values
# indicate to display that layer only. Valid layers are 0..7.
layer = -2

# logger can be 'syslog' or 'printf'. syslog will send all logs to the syslog
# facility. printf will send all logs to the stdout
logger = syslog

# verbose set to true will increase the log level to include state changes and
# debug logging.
verbose = false

# disk_device is meant to be set by the pxSystem section but can be overridden
# here for just this program if desired.
#disk_device =

###############################################################################
# The pxformat section contains settings for the pxformat application.
[pxformat]

# pxformat prompts the user 'are you sure' before formatting the disk when
# prompt is true. To disable this prompt, set this value to false or use the
# --no-prompt command line option.
prompt = true

# max_size_override can be used to limit the maximum size of the formatted disk.
# If the disk is smaller than max_size_override GB then this has no effect. If the
# disk is larger than max_size_override GB then the disk will be formatted to
# max_size_override GB. The valid range is 0 (no limit) to 4294967295 GB.
max_size_override = 0

# user and group are meant to be set by the pxSystem section but can be
# overridden here for just this program if desired.
#user =
#group =

# logger can be 'syslog' or 'printf'. syslog will send all logs to the syslog
# facility. printf will send all logs to the stdout
logger = syslog

# verbose set to true will increase the log level to include state changes and
# debug logging.
verbose = false

# disk_device is meant to be set by the pxSystem section but can be overridden
# here for just this program if desired.
#disk_device =

###############################################################################
# The pxfscheck section contains settings for the pxfscheck application.
[pxfscheck]

# pxfscheck currently can not tell if the disk is actively being written unless
# it is run on the capture system. Therefore, pxfscheck normally prompts the
# user regarding this to make sure the user stops any capture process before
# they run pxfscheck. To disable this prompt, set this value to false or use the
# --no-prompt command line option.
prompt = true

# show status updates while the program is running. This is the default and
# makes sense when a user is running the program from the console. When running
# the program from within another program, this printing can get in the way.
# Setting this to false will cause pxfscheck to only print the final status when
# the application has completed running.
show_status = true

# logger can be 'syslog' or 'printf'. syslog will send all logs to the syslog
# facility. printf will send all logs to the stdout
logger = printf

# verbose set to true will increase the log level to include state changes and
# debug logging.
verbose = false

# disk_device is meant to be set by the pxSystem section but can be overridden
# here for just this program if desired.
#disk_device =

# There is one thread for the file checker
axCheckFsV2/CheckThread =

###############################################################################
# The pxstatistics section contains settings for the pxstatistics application.
[pxstatistics]

# dir is the directory where the statistics files will be written. This
# directory needs to exist when the program is run.
dir = ${pxSystem:axellio_install_path}/stats

# When json is true, the data is output as a json format, otherwise the data is
# output in Prometheus file format.
json = false

# When run is zero, pxstatistics will capture the data from the selected app(s)
# each interval until the user presses control-c or otherwise stops the program
# from running. When run is greater than zero, pxstatistics will capture the
# statistics run number of times and then shut down. Valid range is 0..1000000.
run = 0

# interval defines the time between statistics refreshes in seconds. Valid range
# is 0.1 to 86,400 seconds.
interval = 1.0

# verbose set to true will increase the log level to include state changes and
# debug logging.
verbose = false

# app is used to identify which applications to connect to and obtain statistics
# from. The list consists of IP address and port pairs separated by commas. An
# IP address and port is specified using a colon separator as in
# 'localhost:20000'. Thus an app list can be 'localhost:20000, localhost:20001'
app =

# output_file can be used to override the default file name. This is the base
# file name. The resulting output file name will be a concatenation of the
# directory specified in the dir option, this file name, and a file extension
# based on the type of file being written. This is a comma separated list of
# file names. One file name must be specfied for each application found in the
# app option.
output_file =

###############################################################################
# The pxfsprofile section contains settings for the pxfsprofile application.
[pxfsprofile]

# output_file can be used to send the profile results to a file in csv format.
output_file =

# When plot is true, the profile results will attempt to plot using matplotlib
# python library. If matplotlib is not installed then the application will be
# unable to execute.
plot = false

# default_start_time is the default start time value if no -T or --timestamp
# command line options are present. A start time of 0 means use the earliest
# available data on the disk. A start time of -1 means 'now'. Data with a
# timestamp >= default_start_time and < default_end_time will be processed. Valid
# range is -1 to 4294967295.
default_start_time = 0

# default_end_time is the default end time value if no -T or --timestamp command
# line options are present. An end time of -1 means run forever. The end time
# must be larger than the start time if it is not -1. Data with a timestamp >=
# default_start_time and < default_end_time will be processed. Valid range is -1 to
# 4294967295.
default_end_time = -1

# logger can be 'syslog' or 'printf'. syslog will send all logs to the syslog
# facility. printf will send all logs to the stdout
logger = printf

# verbose set to true will increase the log level to include state changes and
# debug logging.
verbose = false

# disk_device is meant to be set by the pxSystem section but can be overridden
# here for just this program if desired.
#disk_device =

###############################################################################
# The pxstreammon section contains settings for the pxstreammon process. If
# pxstreammon is executed with the --config <name> command line option then the
# pxstreammon-name section will override these settings.
[pxstreammon]

# raw_values of false will display values with units of K,M,G,T as in KB, MB,
# etc. When raw_values is true, the value is displayed as a number.
raw_values = false

# bytes_per_second will choose to display data as bits per second (false) or bytes
# per second (true)
bytes_per_second = true

# interval defines the time between statistics refreshes in seconds. Valid range
# is 0.1 to 86,400 seconds.
interval = 0.2

# extract is a list of pxextract applications to connect to. The list consists
# of IP address and port pairs separated by commas. An IP address and port is
# specified using a colon separator as in 'localhost:20000'. Thus an extract
# list can be 'localhost:20000, localhost:20001'
extract =

# recv is a list of pxrecv applications to connect to. The list consists of IP
# address and port pairs separated by commas. An IP address and port is
# specified using a colon separator as in 'localhost:20000'. Thus a recv list
# can be 'localhost:20000, localhost:20001'
recv =

###############################################################################
# The pxarchive section contains settings for the archive application that is
# moving data to a slower set of disks.
[pxarchive]

# rc_port is the TCP/IP port this application will listen on for remote control
# and status. Valid range is 0 to 65535.
rc_port = 20090

# archive_path specifies the file system location of where to store the archive
# files.
archive_path =

# archive_port is the TCP/IP port this application will listen on for reader
# application management. Readers need to connect to this application in order
# to identify the archive directory and time of data available. Valid range is 1
# to 65535.
archive_port = 21010

# capture_ip_addr is the TCP/IP address of the capture application. Readers need
# to connect to this in order to manage their reading of the disk and prevent
# starving the writer processes. An empty IP Address value disables this
# functionality.
capture_ip_addr =

# capture_port is the TCP/IP port of the capture application management port.
# Readers need to connect to this in order to manage their reading of the disk
# and prevent starving the writer processes. Valid range is 0 to 65535. A value
# of 0 disables this functionality.
capture_port = 21001

# filter is either a BPF filter string (see man 7 pcap-filter) or a tuple
# filter. A tuple filter contains five values with comma separators as follows:
# source_ip,dest_ip,source_port,dest_port,protocol
filter =

# The stream_ids is a list of numbers and ranges using '-' or '..' with comma
# separators between entries
#       n [,n] [,n-m] [,n..m]
#   n and m are integer values in the range 0-255
stream_ids =

# Maximum rate in Mbps to allow archive of data from the disk. A value of 0
# means no maximum.
max_rate = 0

# The archiver will create new files on a maximum file size or time boundary,
# whichever comes first. max_file_size_gb has a range of 1 to 4096GB.
max_file_size_gb = 50

# The archiver will create new files on a maximum file size or time boundary,
# whichever comes first. max_file_size_sec has a range of 0 to 86400 seconds (1
# day). When this is zero, there is no maximum file size in time.
max_file_size_sec = 0

# logger can be 'syslog' or 'printf'. syslog will send all logs to the syslog
# facility. printf will send all logs to the stdout
logger = syslog

# verbose set to true will increase the log level to include state changes and
# debug logging.
verbose = false

# Define the number of file reader threads for each stream ID. Three threads is
# enough for >100Gbps performance for a single stream ID. Valid range is 1 to
# 256.
file_reader_threads = 1

# Define the number of decompression threads for this application. Decompression
# can take quite a bit of CPU depending on the compression level. More threads
# may be required depending on the compression level achieved. Valid range is 1
# to 256.
decompress_threads = 1

# Define the number of filtering threads for this application. Depending on the
# filter type and setting, more threads may be needed to keep application
# performance at full speed. Valid range is 1 to 256.
filter_threads = 2

# Define the number of packet sorting threads for this application. Valid range
# is 1 to 256.
sorter_threads = 4

# max_io_depth defines the maximum number of I/Os that will be queued to the disk
# devices by each file reader thread. Thus file_reader_threads times numStreamIds
# times max_io_depth number of I/Os may be pending. Valid range is 2 to 64.
max_io_depth = 48

# max_q_depth defines the maximum number of queued requests in the system per
# stream ID. This is used for system memory and performance tuning. The valid
# range is 192 to 16384 depending on available system memory.
max_q_depth = 1024

# disk_device is meant to be set by the pxSystem section but can be overridden
# here for just this program if desired.
#disk_device =

# The axTimeoutsSingleton thread is used to generate statistics and is a low
# priority thread.
axTimeoutsSingleton =

# The file reader reads meta-data from the disk, dispatches it to multiple data
# reader threads and then merges the output back into an ordered stream. To
# support multiple streams, the file readers are named with the stream number as
# in 'axFileReader2_stream_3' is a file reader for stream 3.
axFileReader2_stream_*/MetaReader =
axFileReader2_stream_*/MetaDispatch =
axFileReader2_stream_*/DataReader* =
axFileReader2_stream_*/Merge =
axFileReader2_stream_*/CaptureComm =

# The decompress code uses multiple threads to decompress the data
axSegmentDecompress/Decompress* =

# The filter code uses multiple threads to filter the data using BPF or Tuple
# filtering.
axSegmentFilter/Filter* =

# The sorter code uses a single thread to sort all segments by timestamp
axSegmentPacketSorter/Merge =
axSegmentPacketSorter/Sorter* =
axSegmentPacketSorter/SortMerge =

# The archive uses a TCP server to listen for new client connection requests.
# The name of the thread will be TcpServer/Listen:{port}
axSegmentArchive/TcpServer* =

# The archive clients thread processes all client connections
axSegmentArchive/Clients =

# The archive file thread does all of the file writing
axSegmentArchive/FileThread =

[pxrm]
#disk_device =

# verbose set to true will display a minimal set of additional information
verbose = false

[pxreplay]

# rc_port is the TCP/IP port this application will listen on for remote control
# and status. Valid range is 0 to 65535.
rc_port = 20010

# logger can be 'syslog' or 'printf'. syslog will send all logs to the syslog
# facility. printf will send all logs to the stdout
logger = syslog

# verbose set to true will increase the log level to include state changes and
# debug logging.
verbose = false

# Define the number of file reader threads for each stream ID. Three threads is
# enough for >100Gbps performance for a single stream ID. Valid range is 1 to
# 256.
file_reader_threads = 3

# Define the number of decompression threads for this application. Decompression
# can take quite a bit of CPU depending on the compression level. More threads
# may be required depending on the compression level achieved. Valid range is 1
# to 256.
decompress_threads = 4

# Define the number of filtering threads for this application. Depending on the
# filter type and setting, more threads may be needed to keep application
# performance at full speed. Valid range is 1 to 256.
filter_threads = 6

# max_io_depth defines the maximum number of I/Os that will be queued to the disk
# devices by each file reader thread. Thus file_reader_threads times numStreamIds
# times max_io_depth number of I/Os may be pending. Valid range is 2 to 64.
max_io_depth = 48

# max_q_depth defines the maximum number of queued requests in the system per
# stream ID. This is used for system memory and performance tuning. The valid
# range is 192 to 16384 depending on available system memory.
max_q_depth = 1024

# disk_device is meant to be set by the pxSystem section but can be overridden
# here for just this program if desired.
#disk_device =

# Tuning for specific systems can make a big difference. Generic config is blank.
axSegmentReplay/replay_copy_* =
axFileReader2_stream_*/DataReader* =
axSegmentDecompress/Decompress* =
axFileReader2_stream_*/Merge =

[pxmon-pxextract-sec-onion-snsr0-zeek]
interval = 1
##  Address of the APCN
ip_addr = 10.16.50.5
port = 20020

[pxextract-sec-onion-snsr0-zeek]
ip_addr = 10.16.50.10
port=9116
#rcPort = 20020
rc_port = 20020
stream_ids = 0-1
tx_sock_buffer_len = 0x1000000

[pxmon-wtf]
omg=1
